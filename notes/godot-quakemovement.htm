<!DOCTYPE html>
<html lang="en">

<head>
    <title>Mantling in games - notes</title>
    <link rel="alternate" hreflang="en">
    <!--css-->
    <link rel="stylesheet" href="../deco/css/font.css">
    <link rel="stylesheet" href="../deco/css/global.css">
    <link rel="stylesheet" href="../deco/css/Logs.css">
    <!--Favicon-->
    <link rel="apple-touch-icon" sizes="180x180" href="../deco/icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../deco/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../deco/icon/favicon-16x16.png">
    <link rel="manifest" href="../deco/icon/site.webmanifest">
    <link rel="mask-icon" href="../deco/icon/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="../deco/icon/favicon.ico">
    <meta name="apple-mobile-web-app-title" content="Portfolio">
    <meta name="application-name" content="Portfolio">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="../deco/icon/browserconfig.xml">
    <meta name="theme-color" content="#000">
    <!--End Favicon-->
    <!--Discord embed-->
    <meta content="Recreating quake movement" property="og:description" />
    <meta content="https://irishmun.github.io/notes/godot-quakemovement.htm" property="og:url" />
    <meta content="./notes/godot-quakemovement/example.gif" property="og:image" />
    <meta content="#00FFBD" data-react-helmet="true" name="theme-color" />
    <!--End Discord embed-->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>

<body>
    <nav>
        <!--Nav stuff here-->
        <a href="../index.htm">Home</a> /
        <a href="../notes.htm">Notes</a> /
        <a href="../about.htm">About</a> /
        <a href="../portfolio.htm">Portfolio</a> /
        <a href="../links.htm">Links</a>
    </nav>
    <main>
        <h1 class="centered">Recreating Quake / GoldSrc movement in Godot</h1>
        <div class="centered create-date">Created September 9, 2025</div>
        <div>This article was originally written by Andrei Neacsu on <a
                href="https://aneacsu.com/blog/2023-04-09-quake-movement-godot">his blog</a>. This page is used for
            seting up the style for the other notes.</div>
        <hr>
        <p>
            About a year ago, I wanted to try making an FPS game using Godot 3.5.
            I really liked how the player movement in games like Half-life and Quake felt, so I wanted to recreate it.
            I spent a lot of time trying to figure it out, but I never really managed to get my head around it. Finally,
            I tried again, and this time I got something that I’m pretty happy with.
            It might not be perfect, as I still don’t really know what I’m doing, but I wanted to document what I’ve
            learned and share it.
        </p>
        <p>
            This guide will cover how to implement just the character controls and nothing else. The system I’ve come up
            with has smooth movement and the “bug” that lets you bunny hop and surf like in Half-life. I assume you have
            a decent grasp of the fundamentals of Godot, and I won’t be explaining everything in complete detail.
            However, all the code and information you need to get it working for yourself should be on this page.
        </p>
        <p>
            Here is a <a href=""> video example of the script working in game</a>
        </p>
        <p>
            If you would like to download the project files they are also available: <a href="">
                FPS_Player_Controller.zip</a>
        </p>
        <H2>Setup</H2>
        <p>
            First, we need to set up our Player scene. It is just a CharacterController3D with a CollisionShape and a
            Node3D called “Head” which holds our camera.
        </p>
        <div class="centered">
            <img src="./godot-quakemovement/qm-player-structure.jpg" class="image">
        </div>
        <aside>
            <p>*EDIT 2023-04-28: I’ve found that the CylinderShape is actually quite buggy and not as reliable as I
                initially thought. After a bit of testing, I recommend using a capsule instead as it seems to not suffer
                from any of the issues like the cylinder. I will update again if necessary.</p>
        </aside>
        <p>
            The CollisionShape3D is a CylinderShape with a height of 1.4m and radius of 0.5m. This is a rough
            approximation of the player height in Half-life based on the GoldSrc hammer units to real world meters. I’ve
            also decided to use a cylinder for the player shape even though Half-life uses a box because it seems to be
            slightly better at not getting stuck on world geometry, and it is usually the standard that I see nowadays.
        </p>
        <p>
            ...
        </p>
        <p>
            Now in our Player script we can add a few lines to lock the camera to the center of the screen.
        </p>
        <pre>
        <code class="code-block">
func _ready():
    Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
            </code>
        </pre>

        <h2>Camera Rotation</h2>
        <p>
            For camera rotation we check if the input event is an InputEventMouseMotion and the mouse is captured. This
            is just to make sure the camera only moves when the mouse is actually captured in the center of the screen.
        </p>
        <p>
            We rotate the player about the vertical y-axis so that the screen moves left and right. Then we rotate the
            Head about its x-axis so that it moves the camera up and down. We also clamp this rotation to stop the
            camera from flipping over. Each of these inputs is multiplited by a sensitivity modifier which can be
            adjusted to your liking.
        </p>
        <pre>
        <code class="code-block">
# Camera
var sensitivity = 0.05

func _input(event):
	# Camera rotation
	if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		_handle_camera_rotation(event)

func _handle_camera_rotation(event: InputEvent):
	# Rotate the camera based on the mouse movement
	rotate_y(deg_to_rad(-event.relative.x * sensitivity))
	$Head.rotate_x(deg_to_rad(-event.relative.y * sensitivity))

	# Stop the head from rotating to far up or down
	$Head.rotation.x = clamp($Head.rotation.x, deg_to_rad(-60), deg_to_rad(90))
            </code>
        </pre>
        <p>
            ...
        </p>
        <h2>Movement Velocity</h2>
        <p>
            Next is the slightly more complicated part. We have a bunch of new constants which will be used in the
            physics calculations. Most of them are fairly self explanatory but I will still go through them.
        </p>
        <p>
            The <code>MAX_VELOCITY_AIR</code> and <code>MAX_VELOCITY_GROUND</code> are used to limit the maximum velocity which the player can
            travel. They technically don’t work as originally intended, however, they are still required to get the
            appropriate style of movement we are attempting here.
        </p>
    </main>
    <!--Scripts-->
    <!--<script src="./code/clock.js"></script>-->
    <!--<script src="./code/mobile.js"></script>-->
</body>

</html>